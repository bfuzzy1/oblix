<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>oblix-rl demo</title>
  <style>
    body { font-family: sans-serif; text-align: center; background: #1e1e1e; color: #eee; }
    #grid { display: grid; margin: 20px auto; grid-template-columns: repeat(var(--size), 40px); width: fit-content; }
    .cell { width: 40px; height: 40px; border: 1px solid #555; }
    .agent { background: #4caf50; }
    .goal { background: #2196f3; }
    .obstacle { background: #f44336; }
    button { margin: 5px; padding: 8px 16px; border: none; background: #444; color: #fff; cursor: pointer; }
    button:hover { background: #666; }
    canvas { background: #222; border: 1px solid #555; }
  </style>
</head>
<body>
  <h1>oblix-rl Grid World</h1>
  <div id="grid"></div>
  <div id="metrics">
    <div>Episode: <span id="episode">1</span></div>
    <div>Steps: <span id="steps">0</span></div>
    <div>Cumulative Reward: <span id="reward">0</span></div>
    <div>Epsilon: <span id="epsilon">1</span></div>
  </div>
  <canvas id="rewardChart" width="400" height="200"></canvas>
  <div>
    <label>Epsilon: <input type="range" id="epsilon-slider" min="0" max="1" step="0.01" value="1"><span id="epsilon-value">1</span></label>
  </div>
  <div>
    <label>Interval (ms): <input type="range" id="interval-slider" min="10" max="1000" step="10" value="100"><span id="interval-value">100</span></label>
  </div>
  <div>
    <button id="start">Start</button>
    <button id="pause">Pause</button>
    <button id="reset">Reset</button>
    <button id="save">Save</button>
    <button id="load">Load</button>
  </div>
  <script type="module">
    import { GridWorldEnvironment } from './src/rl/environment.js';
    import { RLAgent } from './src/rl/agent.js';
    import { RLTrainer } from './src/rl/training.js';
    import { saveAgent, loadAgent } from './src/rl/storage.js';

    const size = 5;
    const env = new GridWorldEnvironment(size);
    let agent = new RLAgent({ epsilon: 1, epsilonDecay: 0.995, minEpsilon: 0.05 });
    const gridEl = document.getElementById('grid');
    gridEl.style.setProperty('--size', size);
    
    const canvas = document.getElementById('rewardChart');
    const ctx = canvas.getContext('2d');
    const epsilonSlider = document.getElementById('epsilon-slider');
    const epsilonValue = document.getElementById('epsilon-value');
    const intervalSlider = document.getElementById('interval-slider');
    const intervalValue = document.getElementById('interval-value');


    function render(state) {
      gridEl.innerHTML = '';
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          if (env.isObstacle(x, y)) cell.classList.add('obstacle');
          if (x === state[0] && y === state[1]) cell.classList.add('agent');
          if (x === size - 1 && y === size - 1) cell.classList.add('goal');
          cell.addEventListener('click', () => {
            if (x === env.agentPos.x && y === env.agentPos.y) return;
            if (x === size - 1 && y === size - 1) return;
            env.toggleObstacle(x, y);
            render(env.getState());
          });
          gridEl.appendChild(cell);
        }
      }
    }

    const trainer = new RLTrainer(agent, env, {
      intervalMs: 100,
      onStep: (state, reward, done, metrics) => {
        render(state);
        document.getElementById('episode').textContent = metrics.episode;
        document.getElementById('steps').textContent = metrics.steps;
        document.getElementById('reward').textContent = metrics.cumulativeReward.toFixed(2);
        document.getElementById('epsilon').textContent = metrics.epsilon.toFixed(2);

        if (done) drawChart();

        epsilonSlider.value = metrics.epsilon;
        epsilonValue.textContent = metrics.epsilon.toFixed(2);
      }
    });

    epsilonSlider.value = agent.epsilon;
    epsilonValue.textContent = agent.epsilon.toFixed(2);
    intervalSlider.value = trainer.intervalMs;
    intervalValue.textContent = trainer.intervalMs;

    epsilonSlider.addEventListener('input', e => {
      const val = parseFloat(e.target.value);
      agent.epsilon = val;
      trainer.metrics.epsilon = val;
      epsilonValue.textContent = val.toFixed(2);
      document.getElementById('epsilon').textContent = val.toFixed(2);
    });

    intervalSlider.addEventListener('input', e => {
      const val = parseInt(e.target.value, 10);
      trainer.setIntervalMs(val);
      intervalValue.textContent = val;
    });

    document.getElementById('start').onclick = () => trainer.start();
    document.getElementById('pause').onclick = () => trainer.pause();
    document.getElementById('reset').onclick = () => trainer.reset();
    document.getElementById('save').onclick = () => saveAgent(agent);
    document.getElementById('load').onclick = () => {
      agent = loadAgent(trainer);
      render(trainer.state);
    };

    render(env.reset());

    function drawChart() {
      const rewards = trainer.episodeRewards;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (rewards.length === 0) return;
      const max = Math.max(...rewards);
      const min = Math.min(...rewards);
      const range = max - min || 1;
      const stepX = canvas.width / Math.max(rewards.length - 1, 1);
      const points = rewards.map((r, i) => {
        const x = i * stepX;
        const y = canvas.height - ((r - min) / range) * canvas.height;
        return { x, y };
      });
      ctx.beginPath();
      points.forEach(({ x, y }, i) => {
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.strokeStyle = '#4caf50';
      ctx.stroke();
      points.forEach(({ x, y }) => {
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fillStyle = '#4caf50';
        ctx.fill();
      });
    }
  </script>
</body>
</html>
